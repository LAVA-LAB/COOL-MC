//LLM:You’re on a 4 × 4 icy grid: start at pos 0, reach the frisbee at 15 for +1, and avoid the holes at 5, 7, 11, 12 (falling in ends the episode in absorbing state 16). At every step output exactly one action—LEFT (pos − 1), DOWN (pos + 4), RIGHT (pos + 1), or UP (pos − 4); the intended move succeeds with probability 0.33, otherwise you drift sideways, and borders block off-grid moves. Act to maximise the chance of hitting 15.
mdp

//Winter is here. You and your friends were tossing around a
//frisbee at the park when you made a wild throw that left the frisbee out
//in the middle of the lake. The water is mostly frozen, but there are a few
//holes where the ice has melted. If you step into one of those holes, you'll
//fall into the freezing water. At this time, there's an international frisbee shortage,
//so it's absolutely imperative that you navigate across the lake and retrieve the disc.
//However, the ice is control, so you won't always move in the direction you intend.

//The surface is described using a grid like the following:

//SFFF       (S: starting point, safe)
//FHFH       (F: frozen surface, safe)
//FFFH       (H: hole, fall to your doom)
//HFFG       (G: goal, where the frisbee is located)

//The agent controls the movement of a character in a grid world.
//Some tiles of the grid are walkable, and others lead to the agent falling into the water.
//Additionally, the movement direction of the agent is uncertain and only partially depends
//on the chosen direction. The agent is rewarded for finding a walkable path to a goal tile.
//control factor
const double control;
//start position
const int start_position;
const int start = 0;
const int hole1 = 5;
const int hole2 = 7;
const int hole3 = 11;
const int hole4 = 12;
const int done=16;

const int VERTICAL_MOVE=4;
const int HORIZONTAL_MOVE=1;


//Is the agent at a border?
formula TOP_BORDER = (pos <= 3);
formula NOT_TOP_BORDER = (TOP_BORDER = false);
formula RIGHT_BORDER = (pos = 3 | pos = 7 | pos = 11 | pos = 15);
formula NOT_RIGHT_BORDER = (RIGHT_BORDER = false);
formula BOTTOM_BORDER = (pos >= 12 & pos <= 15);
formula NOT_BOTTOM_BORDER = (BOTTOM_BORDER = false);
formula LEFT_BORDER = (pos = 0 | pos = 4 | pos = 8 | pos = 12);
formula NOT_LEFT_BORDER = (LEFT_BORDER = false);
//Hole
formula WATER = (pos=hole1) | (pos=hole2) | (pos=hole3) | (pos=hole4);
formula NOT_IN_HOLE = (WATER = false);
//Frisbee
formula AT_FRISBEE = (pos=15);
formula NOT_AT_FRISBEE = (AT_FRISBEE = false);
formula IS_DONE = (pos=16);
formula NOT_DONE = (IS_DONE = false);
//1223
//4556
//4556
//7889

module agent
	pos: [0..16] init start_position;
	//1
	[UP] TOP_BORDER & LEFT_BORDER & NOT_IN_HOLE & NOT_DONE-> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos);
	//2
	[UP] TOP_BORDER & NOT_LEFT_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-1);
	//3
	[UP] TOP_BORDER  & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos-1);
	//4
	[UP] NOT_TOP_BORDER & LEFT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos);
	//5
	[UP] NOT_TOP_BORDER & NOT_RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_LEFT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-1);
	//6
	[UP] NOT_TOP_BORDER & RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos-1);
	//7
	[UP] LEFT_BORDER & BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos);
	//8
	[UP] NOT_LEFT_BORDER & BOTTOM_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-1);
	//9
	[UP] BOTTOM_BORDER & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1) : (pos'=done);

	//1
	[RIGHT] TOP_BORDER & LEFT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//2
	[RIGHT] TOP_BORDER & NOT_LEFT_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//3
	[RIGHT] TOP_BORDER  & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//4
	[RIGHT] NOT_TOP_BORDER & LEFT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//5
	[RIGHT] NOT_TOP_BORDER & NOT_RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_LEFT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//6
	[RIGHT] NOT_TOP_BORDER & RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//7
	[RIGHT] LEFT_BORDER & BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos);
	//8
	[RIGHT] NOT_LEFT_BORDER & BOTTOM_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos);
	//9
	[RIGHT] BOTTOM_BORDER & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1) : (pos'=done);

	//1
	[DOWN] TOP_BORDER & LEFT_BORDER & NOT_IN_HOLE & NOT_DONE-> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+1);
	//2
	[DOWN] TOP_BORDER & NOT_LEFT_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos+1);
	//3
	[DOWN] TOP_BORDER  & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos);
	//4
	[DOWN] NOT_TOP_BORDER & LEFT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+1);
	//5
	[DOWN] NOT_TOP_BORDER & NOT_RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_LEFT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos+1);
	//6
	[DOWN] NOT_TOP_BORDER & RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos);
	//7
	[DOWN] LEFT_BORDER & BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos+VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+1);
	//8
	[DOWN] NOT_LEFT_BORDER & BOTTOM_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos+1);
	//9
	[DOWN] BOTTOM_BORDER & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1) : (pos'=pos+1);

	//1
	[LEFT] TOP_BORDER & LEFT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//2
	[LEFT] TOP_BORDER & NOT_LEFT_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//3
	[LEFT] TOP_BORDER  & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//4
	[LEFT] NOT_TOP_BORDER & LEFT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//5
	[LEFT] NOT_TOP_BORDER & NOT_RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_LEFT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//6
	[LEFT] NOT_TOP_BORDER & RIGHT_BORDER & NOT_BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos+VERTICAL_MOVE);
	//7
	[LEFT] LEFT_BORDER & BOTTOM_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos);
	//8
	[LEFT] NOT_LEFT_BORDER & BOTTOM_BORDER & NOT_RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1-(1-control)) : (pos'=pos-1) + ((1-control)/2) : (pos'=pos-VERTICAL_MOVE) + ((1-control)/2) : (pos'=pos);
	//9
	[LEFT] BOTTOM_BORDER & RIGHT_BORDER & NOT_IN_HOLE & NOT_DONE -> (1) : (pos'=pos+1);




	//In hole
	[UP] WATER & NOT_DONE -> (pos'=done);
	[RIGHT] WATER & NOT_DONE -> (pos'=done);
	[DOWN] WATER & NOT_DONE -> (pos'=done);
	[LEFT] WATER & NOT_DONE -> (pos'=done);
	//Done (absorbing state)
	[UP] IS_DONE -> (pos'=done);
	[RIGHT] IS_DONE -> (pos'=done);
	[DOWN] IS_DONE -> (pos'=done);
	[LEFT] IS_DONE -> (pos'=done);


endmodule

rewards
	[UP] WATER & NOT_DONE : 0;
	[RIGHT] WATER & NOT_DONE : 0;
	[DOWN] WATER & NOT_DONE : 0;
	[LEFT] WATER & NOT_DONE : 0;

	[UP] NOT_AT_FRISBEE & NOT_IN_HOLE & NOT_DONE : 0;
	[RIGHT] NOT_AT_FRISBEE & NOT_IN_HOLE & NOT_DONE : 0;
	[DOWN] NOT_AT_FRISBEE & NOT_IN_HOLE & NOT_DONE : 0;
	[LEFT] NOT_AT_FRISBEE & NOT_IN_HOLE & NOT_DONE : 0;

	[UP] AT_FRISBEE & NOT_DONE : 1;
	[RIGHT] AT_FRISBEE & NOT_DONE : 1;
	[DOWN] AT_FRISBEE & NOT_DONE : 1;
	[LEFT] AT_FRISBEE & NOT_DONE : 1;

endrewards

label "in_water" = WATER;
label "at_frisbee" = AT_FRISBEE;
